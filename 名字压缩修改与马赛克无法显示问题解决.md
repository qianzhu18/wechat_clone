软件开发修改文档 (SDD v1.4) - 渲染与导出急救包
1. 核心问题一：顶部标题（名字）被压缩
现象：导出时，长标题被挤压，变成竖排或省略号。 根本原因：html2canvas 在计算 Flex 布局时，如果容器宽度不够或受到左右元素（返回箭头、菜单点点）的挤压，它会优先压缩中间的 Flex item。单纯的 flex-shrink: 0 在某些版本的 html2canvas 渲染树中可能失效。

🛠 修改方案：弃用 Flex 居中，改用“绝对定位”强行居中
我们要把中间的标题从 Flex 流中拿出来，让它完全不受左右按钮的影响。

步骤 1: 修改 Header 容器样式
找到顶部导航栏的父容器（Container），确保它有相对定位属性。

CSS

/* 修改前可能的样子 */
.wechat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  /* ... */
}

/* 修改后 (必须包含 position: relative) */
.wechat-header {
  position: relative; /* 关键：为子元素的绝对定位提供锚点 */
  display: flex;
  align-items: center;
  height: 44px; /* 或你设定的固定高度 */
  padding: 0 12px;
  /* justify-content 不需要了，因为我们要手动布局 */
}
步骤 2: 修改标题（名字）样式
给显示名字的那个 <span> 或 <div> 加上绝对定位。

CSS

/* 目标类名：.wechat-header-title */
.wechat-header-title {
  position: absolute;  /* 关键：脱离文档流，不再被左右按钮挤压 */
  left: 50%;           /* 定位到中间 */
  transform: translateX(-50%); /* 精确居中修正 */
  
  /* 加上宽度限制和不换行，防止名字巨长盖住两边按钮 */
  max-width: 60%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: center;
  
  /* 字体样式保持不变 */
  font-weight: 500;
  color: #111111;
  font-size: 17px;
  z-index: 1; /* 确保在最上层 */
}
原理说明：绝对定位的元素不参与 Flex 空间分配，所以无论左边的“返回”和右边的“更多”占多宽，中间的标题永远死死钉在屏幕正中央，html2canvas 对绝对定位的渲染非常稳定。

2. 核心问题二：马赛克（模糊）导出时失效
现象：浏览器预览里有模糊，导出的图片却是清晰的。 根本原因：html2canvas 不支持 CSS filter: blur() 属性。 这是该库的已知硬伤，它在绘制 Canvas 时会直接忽略 filter。

🛠 修改方案：使用“遮罩层”代替“滤镜”
既然滤镜不被支持，我们就用最原始的方法：在头像上面盖一层半透明的磨砂层或马赛克图片。html2canvas 对图层叠加（Stacking）的支持是完美的。

步骤 1: 准备一个马赛克 SVG 或 Base64 图片
我们需要一张看起来像马赛克的小图。这里提供一个简单的 Base64 马赛克图案（或者你可以直接用 CSS 绘制一个半透明白膜）。

方案 A（推荐）：CSS 模拟模糊遮罩 在头像 img 的同一个父容器内，增加一个同级的 div 作为遮罩。

HTML 结构修改：

HTML

<img src="avatar.jpg" class="avatar" style="filter: blur(4px)" />

<div class="avatar-container">
    <img src="avatar.jpg" class="avatar-img" />
    
    <div v-if="privacyMode" class="privacy-mask"></div>
</div>
步骤 2: 编写遮罩 CSS
这个遮罩层不需要真的“模糊”底层图片，只需要它自己看起来“看不清”就行。我们可以用一个半透明的白色覆盖层，或者一个带杂色的覆盖层。

CSS

.avatar-container {
  position: relative; /* 锚点 */
  width: 40px;  /* 头像大小 */
  height: 40px;
  border-radius: 6px;
  overflow: hidden; /* 确保遮罩不溢出圆角 */
}

.avatar-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* 核心修复：用实体层代替 filter */
.privacy-mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  
  /* 方案 1: 简单粗暴的“高斯模糊模拟” - 半透明乳白色 */
  /* 这种效果就像透过磨砂玻璃看，虽然不是真的模糊，但在截图里效果足够像打码 */
  background: rgba(255, 255, 255, 0.85); 
  
  /* 方案 2 (更高级): 如果你想要“像素格”马赛克 */
  /* 使用 CSS 渐变绘制格子 */
  background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                    linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                    linear-gradient(45deg, transparent 75%, #ccc 75%), 
                    linear-gradient(-45deg, transparent 75%, #ccc 75%);
  background-size: 8px 8px; /* 格子大小 */
  background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
}
原理说明：我们不再让浏览器去计算复杂的模糊算法，而是直接在头像上盖了一层“不透明/半透明”的被子。html2canvas 能够完美渲染这层被子，导出的图片就有了“打码”的效果。

3. 额外优化：修复底部二维码文案重影
现象：截图中显示了“长按识别二维码”（深色）和“长按识别二维码”（灰色小字）。 原因：可能是代码里既写了默认文案，又渲染了用户自定义文案，或者 CSS 的伪元素 (::after) 重复渲染了内容。

🛠 修改方案
检查 Footer 组件的代码，保留一个干净的结构。

HTML

<div class="wechat-footer">
    <div class="qr-code-container">
        <img :src="qrCodeUrl" />
    </div>
    <div class="footer-text-container">
        <p class="main-text">长按识别二维码</p>
        </div>
</div>
CSS

.wechat-footer {
  display: flex;
  align-items: center;
  padding: 20px;
  background: white;
  gap: 12px;
}
.main-text {
  font-size: 14px;
  color: #000;
  font-weight: 500;
  margin: 0; /* 确保没有默认边距 */
}
4. 实施清单 (Execution Checklist)
请按顺序执行，每一步执行完刷新页面测试导出：

[ ] 修复标题压缩：

将 Header 容器改为 position: relative。

将 Title 元素改为 position: absolute; left: 50%; transform: translateX(-50%);。

测试：将名字改为超长的“文件传输助手文件传输助手”，查看是否还会被挤压。

[ ] 修复马赛克导出：

删除所有 CSS 中的 filter: blur(...)。

在头像（以及名字）上方添加绝对定位的 .privacy-mask div。

设置 Mask 的背景为半透明白 (rgba(255,255,255,0.85)) 或 CSS 图案。

测试：点击导出，下载图片，打开图片确认头像是否被遮挡。

[ ] 清理底部文案：

删除多余的 <p> 标签或伪元素内容。

完成这两点修改后，最大的技术障碍将被清除。请让 @千逐 立即应用代码。